// Generated by CoffeeScript 1.9.1
(function() {
  var ngReel;

  ngReel = function(window) {
    var module;
    module = window.angular.module('ngReel', ['ngResource']);
    module.factory('Spec0', function($resource) {
      return $resource('http://localhost:3000/alone');
    });
    module.factory('Spec1', function($resource) {
      return $resource('http://localhost:3000/first_users');
    });
    module.factory('Spec2', function($resource) {
      return $resource('http://localhost:3000/second_users');
    });
    module.factory('Spec3', function($resource) {
      return $resource('http://localhost:3000/third_users');
    });
    module.directive('ngReel', function($reel) {
      return {
        scope: true,
        link: function(scope, element, attrs) {
          var as, model, ref, resource;
          scope.reelElement = element[0];
          scope.autoScroll = attrs.ngReelAuto;
          scope.overflow = attrs.ngReelOverflow;
          scope.remember = attrs.ngReelRemember;
          scope.ngReel = attrs.ngReel;
          ref = attrs.ngReel.split(/\s/), resource = ref[0], as = ref[1], model = ref[2];
          scope.resource = resource;
          scope.model = model;
          scope[scope.model] = [];
          scope.read = $reel.remind(scope);
          scope.load = scope.read;
          scope.step = 10;
          scope.feed = scope.step * 2;
          return setTimeout(function() {
            if (scope.autoScroll != null) {
              $reel.autoScroll(scope);
            }
            $reel.scrollInfinite(scope);
            if (scope.overflow != null) {
              return scope.reelElement.addEventListener('scroll', function() {
                return $reel.scrollInfinite(scope);
              });
            } else {
              return window.addEventListener('scroll', function() {
                return $reel.scrollInfinite(scope);
              });
            }
          });
        }
      };
    });
    return module.provider('$reel', function() {
      var $reel, getParamsConfig, getResourceConfig, ref, timeout;
      $reel = {};
      $reel.$get = function($injector, $resource) {
        return {
          scrollInfinite: function(scope) {
            var feeds, reel, scrollBottom, scrollY;
            if (scope.busy != null) {
              return;
            }
            reel = scope.reelElement;
            scrollBottom = document.body.offsetHeight <= window.scrollY + window.innerHeight;
            if (scope.overflow != null) {
              scrollBottom = reel.scrollHeight <= reel.scrollTop + reel.offsetHeight;
            }
            if (scrollBottom) {
              this.request(scope, (function(_this) {
                return function() {
                  return _this.scrollInfinite(scope);
                };
              })(this));
              return;
            }
            if (this.getFeeds(scope).length < scope.feed) {
              this.request(scope, (function(_this) {
                return function() {
                  return _this.scrollInfinite(scope);
                };
              })(this));
              return;
            }
            scrollY = window.scrollY - reel.offsetTop;
            if (scope.overflow != null) {
              scrollY = scope.reelElement.scrollTop;
            }
            feeds = this.getFeeds(scope, scope.step);
            if (scrollY > feeds.height) {
              this.read(feeds, scope);
              this.request(scope, (function(_this) {
                return function() {
                  return _this.scrollInfinite(scope);
                };
              })(this));
            }
          },
          request: function(scope, callback) {
            var params;
            if (callback == null) {
              callback = null;
            }
            params = this.getParams(scope);
            scope.busy = true;
            return this.getResource(scope.resource).query(params, (function(_this) {
              return function(resources) {
                var j, len, resource;
                if (resources.length) {
                  for (j = 0, len = resources.length; j < len; j++) {
                    resource = resources[j];
                    scope[scope.model].push(resource);
                  }
                  scope.load += resources.length;
                  scope.busy = null;
                  if (callback != null) {
                    return callback(resources);
                  }
                } else {
                  if (scope.load === 0) {
                    throw new Error('Resource not found');
                  }
                  scope.busy = null;
                  scope.read = 0;
                  scope.load = 0;
                  return _this.request(scope, callback);
                }
              };
            })(this));
          },
          response: function(scope, resources) {},
          read: function(feeds, scope) {
            var i, j, len;
            if (scope.overflow === void 0) {
              window.scrollTo(0, window.scrollY - feeds.height);
            }
            scope.reelElement.scrollTop -= feeds.height;
            for (j = 0, len = feeds.length; j < len; j++) {
              i = feeds[j];
              scope[scope.model].shift();
            }
            scope.read += feeds.length;
            scope.$apply();
            return this.mind(scope);
          },
          getName: function(scope) {
            var name;
            name = 'ngReel:' + scope.remember;
            if (scope.remember === '') {
              return name = scope.ngReel;
            }
          },
          mind: function(scope) {
            if (scope.remember != null) {
              return localStorage.setItem(this.getName(scope), scope.read);
            }
          },
          remind: function(scope) {
            if (scope.remember != null) {
              return new Number(localStorage.getItem(this.getName(scope)));
            }
            return 0;
          },
          reset: function(name) {
            var reel;
            reel = this.reels[name];
            localStorage.removeItem(this.getName(reel));
            return console.log(reel);
          },
          getResource: function(name, paramDefaults) {
            var Resource;
            if (paramDefaults == null) {
              paramDefaults = null;
            }
            Resource = getResourceConfig.apply(null, arguments);
            if (Resource === void 0) {
              if ($injector.has(name)) {
                Resource = $injector.get(name);
              }
              if (Resource === void 0) {
                Resource = $resource(name, paramDefaults);
              }
            }
            return Resource;
          },
          getParams: function(scope) {
            var params;
            params = getParamsConfig.apply(null, arguments);
            if (params === void 0) {
              params = {
                _start: scope.load,
                _end: scope.load + (scope.feed - this.getFeeds(scope).length)
              };
              if (params._end <= params._start) {
                params._end = params._start + 1;
              }
            }
            return params;
          },
          getFeeds: function(scope, length) {
            var feed, feeds, i, j, len, ref, ref1;
            if (length == null) {
              length = null;
            }
            feeds = [];
            feeds.height = 0;
            ref = scope.reelElement.querySelectorAll('[ng-repeat]');
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              feed = ref[i];
              if ((length != null) && i >= length) {
                break;
              }
              feeds.push(feed);
              feeds.height += (ref1 = feed != null ? feed.offsetHeight : void 0) != null ? ref1 : feed != null ? feed.clientHeight : void 0;
            }
            return feeds;
          },
          autoScroll: function(scope) {
            var nextFrame, scrollY;
            scrollY = ~~scope.autoScroll;
            if (scrollY <= 0) {
              scrollY = 3;
            }
            timeout(function() {
              return nextFrame();
            });
            return nextFrame = function() {
              if (scope.overflow != null) {
                scope.reelElement.scrollTop += scrollY;
              }
              if (scope.overflow === void 0) {
                window.scrollTo(0, window.scrollY + scrollY);
              }
              return timeout(nextFrame);
            };
          }
        };
      };
      timeout = (ref = window != null ? window.requestAnimationFrame : void 0) != null ? ref : setTimeout;
      $reel.getResource = function(config) {
        var getResource;
        return getResource = config;
      };
      $reel.getParams = function(config) {
        var getParams;
        return getParams = config;
      };
      getResourceConfig = function() {
        return void 0;
      };
      getParamsConfig = function() {
        return void 0;
      };
      return $reel;
    });
  };

  if ((typeof window !== "undefined" && window !== null ? window.angular : void 0) != null) {
    ngReel(window);
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ngReel;
  }

}).call(this);
